#include <bits/stdc++.h>
using namespace std;
#define fastio                        \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL)
#define i64 int64_t
#define printmsg(msg, first, last) cout << msg; for(auto it = first; it != last; it++){cout << *it << "|";} cout << endl;


template<typename T, typename U>
ostream& operator<<(ostream& os, pair<T, U> p){
    os << "(" << p.first << "," << p.second << ")";
    return os;
}

/*
Let f[i] be the frequency of value i. Let p[i] = sum(j <= i)j * f[j]

Definition: we say {1,..,j} generates [1,..,k] if there is 0 <= c_i <= f_i for all i <= j with sum(i<=j) c_i * i = l
for all 1 <= l <= k
    (so each value in [1,..,k] can be generated with only denominations 1,..,j)

Claim: If i >= 1 and, for all j < i,
1.  p[j] >= j
and
2. {1,..,j} generates [0,..,j] for all j < i,
then {1,..,i} generates [0,..,p[i]]

NOTE: p[i - 1] >= i - 1 means loosely that denominations 1,..,i-1 can "cover all equivalence classes of i"

Proof (induction):
* Base case i = 1 is trivial: {1} generates [1,..,p[1]], which is either the empty set or [1 * 1, 2 * 1, ..., f[1] * 1]
* Induction hypothesis (for i >= 2):
    By hypothesis {1,...,i-2} generates {1,...,i-2} with the p-inequalities met and so [1,...,i-1] generates [1,..,p[i-1]]

    Take some 1 <= x <= p[i].
    1. If x <= i * f[i], take q = x / i and r = x mod i. Then 0 <= r <= i - 1 so it is generated by {1,..,i-1} (as p[i - 1] >= i - 1), and x - r = q*i,
    so x is generated by denominations {1,..,i}
    2. If x > i * f[i] take r = x - f[i] * i. Then 0 <= r <= x - f[i] * i = p[i] - f[i] * i = p[i - 1] so r is generated by {1,...,i-1}
    and so x is generated by denominations {1,..,i}


The first time this condition is not met (so p[i] < i) then p[i]+1 <= i is not generated by {1,..,i+1}, since it can't afford to have an i+1
in the sum and is not generated by {1,...,i} (as the total sum of those denominations is p[i] < p[i]+1)
*/
int main()
{
    i64 n;
    cin >> n;
    map<i64, i64> f, p;

    for (i64 i = 0; i < n; i++)
    {
        i64 x;
        cin >> x;
        ++f[x];
    }
    i64 last = -1;
    for (auto[k, c]: f){
        p[k] = k * c;
        if (last != -1){
            p[k] += p[last];
        }
        last = k;
    }

    vector<i64> keys;
    for (auto[k, _]: f){
        keys.emplace_back(k);
    }
    keys.insert(keys.begin(), 0);  // dummy key to account for cases where keys[0] > 1
    p[0] = 0;
    const i64 k = keys.size();

    for (i64 i = 0; i + 1 < k; i++){
        // look at interval keys[i]...keys[i+1]-1
        // if p[keys[i]] < keys[i+1]-1
        // then p[keys[i]] + 1 <= keys[i+1] - 1 and p[keys[i]] + 1 is not covered!
        // because p[p[keys[i]] + 1] = p[keys[i]] (since key i+1 is not available) < p[keys[i]] + 1
        // so answer according to proof above if (p[p[keys[i]] + 1]) + 1 = p[keys[i]] + 1
        if (p[keys[i]] < keys[i + 1] - 1){
            cout << p[keys[i]] + 1 << endl;
            return 0;
        }
    }
    cout << p[keys.back()] + 1 << endl;
}
